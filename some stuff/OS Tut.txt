/**************************************************
 * Invest OS
 **************************************************/
 Following are some of important functions of an operating System:
 1.Memory Management
 2.Processor Management
 3.Device Management
 4.File Management
 5.Other Activities: Security , Control over system performance, Job accounting, Error detecting aids, Coordination between other softwares and users
/**********
 * 1.Memory Management
 ***********/
 1. Memory concept and component:
  The memory system is constructed as a hierarchy:
    + The top layer consists of the registers internal to the CPU. size < 1KB
    + Next comes the cache memory, which is mostly controlled by the hardware. size < 1 MB
    + Main memory comes next. This is the workhorse of the memory system. Main memory is often called RAM (Random Access Memory). In addition to the kinds of memory discussed above, many computers have a small amount of nonvolatile random access memory. Unlike RAM, nonvolatile memory does not lose its contents when the power is switched off. ROM (Read Only Memory) is programmed at the factory and cannot be changed afterward.
    (On some computers, the bootstrap loader used to start the computer is contained in ROM. Also, some I/O cards come with ROM for handling low-level device control.)
    + Next in the hierarchy is magnetic disk (hard disk). 
 2. Management
  Memory management is the functionality of an operating system which handles or manages primary memory and moves processes back and forth between main memory and disk during execution.
  a. Process Address Space
   The process address space is the set of logical addresses that a process references in its code.
   The operating system takes care of mapping the logical addresses to physical addresses at the time of memory allocation to the program. There are three types of addresses
    - Symbolic addresses: The addresses used in a source code. The variable names, constants, and instruction labels are the basic elements of the symbolic address space.
    - Relative addresses: At the time of compilation, a compiler converts symbolic addresses into relative addresses.
    - Physical addresses: The loader generates these addresses at the time when a program is loaded into main memory.
   The set of all logical addresses (virtual address) generated by a program is referred to as a logical address space. The set of all physical addresses corresponding to these logical addresses is referred to as a physical address space.
    The runtime mapping from virtual to physical address is done by the memory management unit (MMU) which is a hardware device.
  b. Static vs Dynamic Loading
   At the time of loading, with static loading, the absolute program (and data) is loaded into memory in order for execution to start. (when static linking is used, the linker combines all other modules needed by a program into a single executable program to avoid any runtime dependency.)
   If you are using dynamic loading, dynamic routines of the library are stored on a disk in relocatable form and are loaded into memory only when they are needed by the program.(When dynamic linking is used, it is not required to link the actual module or library with the program, rather a reference to the dynamic module is provided at the time of compilation and linking.)
  c. Swapping
    Swapping is a mechanism in which a process can be swapped temporarily out of main memory (or move) to secondary storage (disk) and make that memory available to other processes.
  d. Memory Allocation
    Main memory usually has two partion:
        Low Memory − Operating system resides in this memory.
        High Memory − User processes are held in high memory.
    Multiple-partition allocation:
     In this type of allocation, main memory is divided into a number of fixed-sized partitions where each partition should contain only one process. When a partition is free, a process is selected from the input queue and is loaded into the free partition. When the process terminates, the partition becomes available for another process.
  e. Fragmentation
     - External fragmentation: Total memory space is enough to satisfy a request or to reside a process in it, but it is not contiguous, so it cannot be used.
     - Internal fragmentation: Memory block assigned to process is bigger. Some portion of memory is left unused, as it cannot be used by another process.
     External fragmentation can be reduced by compaction or shuffle memory contents to place all free memory together in one large block.
     The internal fragmentation can be reduced by effectively assigning the smallest partition but large enough for the process.
  f. Paging
    A computer can address more memory than the amount physically installed on the system. This extra memory is actually called virtual memory and it is a section of a hard that's set up to emulate the computer's RAM.
    Paging is a memory management technique in which process address space is broken into blocks of the same size called pages. The size of the process is measured in the number of pages.
    Similarly, main memory is divided into small fixed-sized blocks of (physical) memory called frames.
    Size of a frame is kept to avoid external fragmentation.
  g. Address Translation
    Page address is called logical address and represented by page number and the offset: Logical Address = Page number + page offset
    Frame address is called physical address and represented by a frame number and the offset: Physical Address = Frame number + page offset
    A data structure called page map table is used to keep track of the relation between a page of a process to a frame in physical memory.
    When a process is to be executed, its corresponding pages are loaded into any available memory frames. Suppose you have a program of 8Kb but your memory can accommodate only 5Kb at a given point in time, then the paging concept will come into picture. When a computer runs out of RAM, the operating system (OS) will move idle or unwanted pages of memory to secondary memory to free up RAM for other processes and brings them back when needed by the program.
  h. Segmentation
    Segmentation is a memory management technique in which each job is divided into several segments of different sizes, one for each module that contains pieces that perform related functions. Each segment is actually a different logical address space of the program.
  i. Virtual Memory 
    A computer can address more memory than the amount physically installed on the system. This extra memory is actually called virtual memory and it is a section of a hard disk that's set up to emulate the computer's RAM.
 /**********
 * 2.Processor Management
 ***********/
 1. Concept:
  A process is basically a program in execution.
    a. Address space
       Associated with each process is its address space, a list of memory locations from some minimum (usually 0) to some maximum, which the process can read and write. The address space contains the executable program, the program’s data, and its stack. 
       + Stack: The process Stack contains the temporary data such as method/function parameters, return address and local variables.
       + Heap: This is dynamically allocated memory to a process during its run time.
       + Text: This includes the current activity represented by the value of Program Counter and the contents of the processor's registers.
       + Data: This section contains the global and static variables.
    b. Process state
       + Start: This is the initial state when a process is first started/created.
       + Ready: The process is waiting to be assigned to a processor. Ready processes are waiting to have the processor allocated to them by the operating system so that they can run. Process may come into this state after Start state or while running it by but interrupted by the scheduler to assign CPU to some other process.
       + Running: Once the process has been assigned to a processor by the OS scheduler, the process state is set to running and the processor executes its instructions.
       + Waiting: Process moves into the waiting state if it needs to wait for a resource, such as waiting for user input, or waiting for a file to become available.
       + Terminated or Exit: Once the process finishes its execution, or it is terminated by the operating system, it is moved to the terminated state where it waits to be removed from main memory.
    c. Process Control Block (PCB)
        In many operating systems, all the information about each process, other than the contents of its own address space, is stored in an operating system table called the process table
        1 Process State: The current state of the process i.e., whether it is ready, running, waiting, or whatever.
        2 Process privileges: This is required to allow/disallow access to system resources.
        3 Process ID: Unique identification for each of the process in the operating system.
        4 Pointer: A pointer to parent process.
        5 Program Counter: Program Counter is a pointer to the address of the next instruction to be executed for this process.
        6 CPU registers: Various CPU registers where process need to be stored for execution for running state.
        7 CPU Scheduling Information: Process priority and other scheduling information which is required to schedule the process.
        8 Memory management information: This includes the information of page table, memory limits, Segment table depending on memory used by the operating system.
        9 Accounting information: This includes the amount of CPU used for process execution, time limits, execution ID etc.
        10 IO status information: This includes a list of I/O devices allocated to the process.
 2. Interprocess communication
 3. Process Scheduling:
    a. Context Switch
        A context switch is the mechanism to store and restore the state or context of a CPU in Process Control block so that a process execution can be resumed from the same point at a later time. Using this technique, a context switcher enables multiple processes to share a single CPU. Context switching is an essential part of a multitasking operating system features.
    b. Scheduling in Batch Systems
        - First Come- First Served
        - Shortest Job First
        - Shortest Remaining Time Next 
        Three level Scheduling: admission scheduler -> memory scheduler -> CPU scheduler.
    c. Scheduling in Interactive Systems 
        - Round-Robin Scheduling 
        - Priority Scheduling 
        - Multiple Queues
        - 
    d. Scheduling in Real-Time Systems 
        A real-time system is one in which time plays an essential role. Typically, one or more physical devices external to the computer generate stimuli, and the computer must react appropriately to them within a fixed amount of time.
        Real-time systems are generally categorized as hard real time, meaning there are absolute deadlines that must be met, or else, and soft real time, meaning that missing an occasional deadline is undesirable, but nevertheless tolerable.
 4. Thread

 /**********
 * 3.Device Management
 ***********/
/**********
 * 4.File Management 
 ***********/

/**********
 * 5.Other Activities:
 ***********/
 
/**************
 * 6. OS Type
 */
 1. Batch operating system
 The users of a batch operating system do not interact with the computer directly. Each user prepares his job on an off-line device like punch cards and submits it to the computer operator.
 2. Time-sharing operating systems
 Time-sharing is a technique which enables many people, located at various terminals, to use a particular computer system at the same time. Time-sharing or multitasking is a logical extension of multiprogramming. Processor's time which is shared among multiple users simultaneously is termed as time-sharing.
 3. Distributed operating System
 Distributed systems use multiple central processors to serve multiple real-time applications and multiple users. Data processing jobs are distributed among the processors accordingly.
 4. Network operating System
 A Network Operating System runs on a server and provides the server the capability to manage data, users, groups, security, applications, and other networking functions. The primary purpose of the network operating system is to allow shared file and printer access among multiple computers in a network, typically a local area network (LAN), a private network or to other networks.
 5. Real Time operating System
 A real-time system is defined as a data processing system in which the time interval required to process and respond to inputs is so small that it controls the environment.
 There are two types of real-time operating systems.
 Hard real-time systems: Hard real-time systems guarantee that critical tasks complete on time. In hard real-time systems, secondary storage is limited or missing and the data is stored in ROM. 
 Soft real-time systems: Soft real-time systems are less restrictive. A critical real-time task gets priority over other tasks and retains the priority until it completes.