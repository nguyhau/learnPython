/**/
echo -n "text"|sha1sum
// ref https://www.di-mgt.com.au/rsa_alg.html#decryption
* The Extended Euclidean Algorithm
 INPUT: Two non-negative integers a and b with a ≥ b.
 OUTPUT: d = gcd(a, b) and integers x and y satifying ax + by = d.
 
     If b = 0 then set d = a, x = 1, y = 0, and return(d, x, y).
     Set x2 = 1, x1 = 0, y2 = 0, y1 = 1
     While b > 0, do
         q = floor(a/b), r = a - qb, x = x2 - qx1, y = y2 - q y1.
         a = b, b = r, x2 = x1, x1 = x, y2 = y1, y1 = y.
     Set d = a, x = x2, y = y2, and return(d, x, y).
 
/** Original RSA */

1. Generate two large random primes, p and q, of approximately equal size such that their product n = pq is of the required bit length, e.g. 1024 bits. [See note 1].
2. Compute n = pq and (phi) φ = (p-1)(q-1). [See note 6].
3. Choose an integer e, 1 < e < phi, such that gcd(e, phi) = 1. [See note 2].
4. Compute the secret exponent d, 1 < d < phi, such that ed ≡ 1 (mod phi). [See note 3].
5. The public key is (n, e) and the private key (d, p, q). Keep all the values d, p, q and phi secret. 
[We prefer sometimes to write the private key as (n, d) because you need the value of n when using d. Other times we might write the key pair as ((N, e), d).]

- n is known as the modulus.
- e is known as the public exponent or encryption exponent or just the exponent.
- d is known as the secret exponent or decryption exponent.

/** Encryption*/
 Sender A does the following:
    1. Obtains the recipient B's public key (n, e).
    2. Represents the plaintext message as a positive integer m, 1 < m < n [see note 4].
    3. Computes the ciphertext c = m^e mod n.
    4. Sends the ciphertext c to B.
	
/** Decryption */
 Recipient B does the following:-
    1. Uses his private key (n, d) to compute m = c^d mod n.
    2. Extracts the plaintext from the message representative m.

/** Digital signing */	
Sender A does the following:-
    1. Creates a message digest of the information to be sent.
    2. Represents this digest as an integer m between 1 and n-1. [See note 5]
		m=(m^e mod n)^d mod n=(m^d mod n)^e mod n.
    3. Uses her private key (n, d) to compute the signature s = m^d mod n.
    4. Sends this signature s to the recipient, B.

/** Signature verification */	
 Recipient B does the following:-
    1. Uses sender A's public key (n, e) to compute integer v = s^e mod n.
    2. Extracts the message digest from this integer.
    3. Independently computes the message digest of the information that has been signed.
    4. If both message digests are identical, the signature is valid.

INPUT: Required modulus bit length, k.
OUTPUT: An RSA key pair ((N,e), d) where N is the modulus, the product of two primes (N=pq) not exceeding k bits in length;
 e is the public exponent, a number less than and coprime to (p-1)(q-1); 
 and d is the private exponent such that ed ≡ 1 (mod (p-1)(q-1)).

    1. Select a value of e from {3, 5, 17, 257, 65537}
    2. repeat
    3.    p ← genprime(k/2)
    4. until (p mod e) ≠ 1
    5. repeat
    6.    q ← genprime(k - k/2)
    7. until (q mod e) ≠ 1
    8. N ← pq
    9. L ← (p-1)(q-1)
   10. d ← modinv(e, L) // search d: e*d mod L = 1
   11. return (N, e, d)
	
/** Example */

1. We choose e = 3
2. We select primes p=173 and q=149 and check
	gcd(e, p-1) = gcd(3, 172) = 1 ⇒ OK
	gcd(e, q-1) = gcd(3, 148) = 1 ⇒ OK.
3. Thus we have n = pq = 173 × 149 = 25777, and
	phi = (p-1)(q-1) = 172 × 148 = 25456.
4. We compute d = e-1 mod phi = 3-1 mod 25456 = 16971.
	Note that ed = 3 × 16971 = 50913 = 2 × 25456 + 1
	That is, ed ≡ 1 mod 25456 ≡ 1 mod phi
5. Hence our public key is (n, e) = (25777, 3) and our private key is (n, d) = (25777, 16971). We keep the values of p, q, d and phi secret.


/*************************************************************************
 * Algorithm: Encryption using PKCS#1v1.5 
 *************************************************************************/
 INPUT: Recipient's RSA public key, (n, e) of length k = |n| bytes; data D (typically a session key) of length |D| bytes with |D|<=k-11.
 OUTPUT: Encrypted data block of length k bytes

1.  Form the k-byte encoded message block, EB,

    EB = 00 || 02 || PS || 00 || D

    where || denotes concatenation and PS is a string of k-|D|-3 non-zero randomly-generated bytes (i.e. at least eight random bytes).
2.  Convert the byte string, EB, to an integer, m, most significant byte first,

    m = StringToInteger(EB)

3.  Encrypt with the RSA algorithm

    c = m^e mod n //Note:  bc mod n = (b mod n).(c mod n) mod n

4.  Convert the resulting ciphertext, c, to a k-byte output block, OB‡

    OB = IntegerToString(c, k)

5.  Output OB.


6. Decryption:
	c = StringToInteger(OB)
	d = e-1 mod n
	m = c^d mod n
	-> D
/** Example */
1. Bob's 1024-bit RSA encryption key in hex format:
	n=
	A9E167983F39D55FF2A093415EA6798985C8355D9A915BFB1D01DA197026170F
	BDA522D035856D7A986614415CCFB7B7083B09C991B81969376DF9651E7BD9A9
	3324A37F3BBBAF460186363432CB07035952FC858B3104B8CC18081448E64F1C
	FB5D60C4E05C1F53D37F53D86901F105F87A70D1BE83C65F38CF1C2CAA6AA7EB
	e=010001
	d=
	67CD484C9A0D8F98C21B65FF22839C6DF0A6061DBCEDA7038894F21C6B0F8B35
	DE0E827830CBE7BA6A56AD77C6EB517970790AA0F4FE45E0A9B2F419DA8798D6
	308474E4FC596CC1C677DCA991D07C30A0A2C5085E217143FC0D073DF0FA6D14
	9E4E63F01758791C4B981C3D3DB01BDFFA253BA3C02C9805F61009D887DB0319

2. A randomly-generated one-off session key for AES-128 might be (16byte)

	D=4E636AF98E40F3ADCFCCB698F4E80B9F

3. The encoded message block, EB, after encoding but before encryption, with random padding bytes shown in green,

	00|02|257F48FD1F1793B7E5E02306F2D3228F5C95ADF5F31566729F132AA12009
	E3FC9B2B475CD6944EF191E3F59545E671E474B555799FE3756099F044964038
	B16B2148E9A2F9C6F44BB5C52E3C6C8061CF694145FAFDB24402AD1819EACEDF
	4A36C6E4D2CD8FC1D62E5A1268F496|00|4E636AF98E40F3ADCFCCB698F4E80B9F

4. After RSA encryption, the output is

	3D2AB25B1EB667A40F504CC4D778EC399A899C8790EDECEF062CD739492C9CE5
	8B92B9ECF32AF4AAC7A61EAEC346449891F49A722378E008EFF0B0A8DBC6E621
	EDC90CEC64CF34C640F5B36C48EE9322808AF8F4A0212B28715C76F3CB99AC7E
	609787ADCE055839829E0142C44B676D218111FFE69F9D41424E177CBA3A435B

/*************************************************************************
 * Algorithm: Signing using PKCS#1v1.5 
 * IntegerToString(i, n) is an n-byte encoding of the integer i with the most significant byte first (i.e. in "big-endian" order). So, for example
 * 		IntegerToString(1,4)="00000001"; IntegerToString(7658,3)="001DEA"
 * StringToInteger(S) is the integer represented by the byte string S with the most significant byte first.
 *************************************************************************/
 INPUT: Sender's RSA private key, (n, d) of length k = |n| bytes; message, M, to be signed; message digest algorithm, Hash.
 OUTPUT: Signed data block of length k bytes

1.  Compute the message digest H of the message,

    H = Hash(M)

2.  Form the byte string, T, from the message digest, H, according to the message digest algorithm, Hash, as follows
    Hash	|T
    MD5		|30 20 30 0c 06 08 2a 86 48 86 f7 0d 02 05 05 00 04 10 || H
    SHA-1	|30 21 30 09 06 05 2b 0e 03 02 1a 05 00 04 14 || H
    SHA-224	|30 2d 30 0d 06 09 60 86 48 01 65 03 04 02 04 05 00 04 1c || H
    SHA-256	|30 31 30 0d 06 09 60 86 48 01 65 03 04 02 01 05 00 04 20 || H
    SHA-384	|30 41 30 0d 06 09 60 86 48 01 65 03 04 02 02 05 00 04 30 || H
    SHA-512	|30 51 30 0d 06 09 60 86 48 01 65 03 04 02 03 05 00 04 40 || H
    where T is an ASN.1 value of type DigestInfo encoded using the Distinguished Encoding Rules (DER).
3.  Form the k-byte encoded message block, EB,

    EB = 00 || 01 || PS || 00 || T

    where || denotes concatenation and PS is a string of bytes all of value 0xFF of such length so that |EB|=k.
4.  Convert the byte string, EB, to an integer m, most significant byte first,

    m = StringToInteger(EB)

5.  Sign with the RSA algorithm

    s = m^d mod n

6.  Convert the resulting signature value, s, to a k-byte output block, OB

    OB = IntegerToString(s, k)

7.  Output OB.
 
/** Example */ 
0. Alice's 1024-bit RSA signing key in hex format:
   n=
   E08973398DD8F5F5E88776397F4EB005BB5383DE0FB7ABDC7DC775290D052E6D 
   12DFA68626D4D26FAA5829FC97ECFA82510F3080BEB1509E4644F12CBBD832CF 
   C6686F07D9B060ACBEEE34096A13F5F7050593DF5EBA3556D961FF197FC981E6 
   F86CEA874070EFAC6D2C749F2DFA553AB9997702A648528C4EF357385774575F 
   e=010001
   d=
   00A403C327477634346CA686B57949014B2E8AD2C862B2C7D748096A8B91F736
   F275D6E8CD15906027314735644D95CD6763CEB49F56AC2F376E1CEE0EBF282D
   F439906F34D86E085BD5656AD841F313D72D395EFE33CBFF29E4030B3D05A28F
   B7F18EA27637B07957D32F2BDE8706227D04665EC91BAF8B1AC3EC9144AB7F21

1. The message to be signed is, of course,
	M="abc"
	that is, the 3 bytes in hex format,
	PT=616263

2.  The message digest algorithm is SHA-1, so //ex: echo -n "abc"|sha1sum
	H = Hash("abc") = A9993E364706816ABA3E25717850C26C9CD0D89D

2.1  The DigestInfo value for SHA-1 is
	T= 3021300906052B0E03021A05000414|A9993E364706816ABA3E25717850C26C9CD0D89D

3.  The encoded message block, EB, after encoding but before signing is
	m = 
	0001FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00302130
	0906052B0E03021A05000414A9993E364706816ABA3E25717850C26C9CD0D89D

4.  After RSA signing, the output is
	s=m^d mod n
	60AD5A78FB4A4030EC542C8974CD15F55384E836554CEDD9A322D5F4135C6267
	A9D20970C54E6651070B0144D43844C899320DD8FA7819F7EBC6A7715287332E
	C8675C136183B3F8A1F81EF969418267130A756FDBB2C71D9A667446E34E0EAD
	9CF31BFB66F816F319D0B7E430A5F2891553986E003720261C7E9022C0D9F11F

	
/*************************************************************/
send M;
H = hash(M);
send sequence:
(M+H)~(s_a)~(p_b)-> (r_b)~(p_a): M+H. hash(M)-> authen: compare hash(M) with H.	

/*************************************************************************
 * Digital Signature Scheme: 
 * http://clem.dii.unisi.it/~vipp/files/MultimediaSecurity/MS_cryptoMISC.pdf
 *************************************************************************/
  It consists of 3 algorithms: 
 • A CA uses a key generation algorithm G to produce a "key pair" (PK, SK) for the signer. 
 • PK is the verifying key, which is to be public, and SK is the signing key, to be kept private. 
 • Authenticity of the key is ensured by a certificate 

/**************************************************************************
 * Deploy system using openssl 
 */
 mkdir CA
 mkdir CA/signed_certs
 mkdir CA/private
 cp /etc/ssl/openssl.cnf CA
 touch index.txt
 #========= create ca_req and ca_key
 openssl req -new -keyout private/cakey.pem -out careq.pem -config ./openssl.cnf
 # signed for req: out cacert
 openssl ca -create_serial -out cacert.pem -keyfile private/cakey.pem -selfsign -extensions v3_ca -config ./openssl.cnf -in careq.pem
 
 #========= generate server key
 openssl req -new -config ./openssl.cnf -keyout server_key.pem -out server_req.pem
 # signe for server req:
 openssl ca -config ./openssl.cnf -in server_req.pem -out server_cert.pem
 
 #========= generate client key
 openssl req -new -config ./openssl.cnf -keyout linux_laptop_key.pem -out linux_laptop_req.pem
 # signed for client req
 openssl ca -config ./openssl.cnf -in linux_laptop_req.pem -out linux_laptop_cert.pem
 
 # PKCS12
 openssl pkcs12 -export -clcerts -in linux_laptop_cert.pem -inkey linux_laptop_key.pem -out linux_laptop.p12
 # Server need file: cacert.pem server_cert.pem server_key.pem 
 # Client need file: cacert.pem linux_laptop.p12
